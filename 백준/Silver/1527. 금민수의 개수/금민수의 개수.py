'''
은민이는 4, 7을 좋아하고 나머지 숫자는 싫어한다. 금민수는 4와 7로만 이루어진 수를 말한다.
A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력하는
프로그램을 구하여라!
'''
'''
4와 7로만 이루어진 숫자를 구해야하는데 아~ 범위를 보면 알겠지만 그냥 구하라고 하면 터질거다
흠.. 일단 처음 떠오르는건 세그먼트 트리였는데 생각해보면 결국 리프노드에서 금민수인지를
판단해야 하므로 결국 각각 확인하는건 똑같다 미리 계산하는 느낌이 아니고 구하고자 하는 구간이 주어지기 때문에
세그먼트 트리는 아닌듯?
흠 그 다음은 DP 생각해보자 어떤 한 구간이 주어진다.
1~10에서 금민수는 4,7뿐이다
10~100은 44 47 74 77 뿐이다
100~ 1000은 444 447 474 477 744 774 747 777이고 (8개)
1000 ~ 10000은 4444 4447 4474 4744 7444 4477 4747 4774 7447 7474 7744 4777 7477 7747 7774 7777 (16개)
10000 ~100000 = 32
100000 ~ 1000000 = 64
1000000 ~ 10000000 = 128
오호 구간별로 2의 제곱수만큼 존재한다!
그런데... 어차피 구간이 주어지니까... 애매해졌네...
10~40 까지 주어진다하면 어떻게 판단할 것인가? 10 ~ 70이면?? 10 ~ 45면?? 흠...
오.... 해당 구간에서 계속 딥하게 들어가면 될것 같은데..?
예시로 100만에서 천만사이는 128이다
만약, 구간이 100만~500만이라면 4로 시작하는 금민수의 개수는 딱 절반 64개이다
만약 100~450만이라면 금민수의 개수는 32개다
만약 100~445만이면 16개다
만약 100만~ 4445000이면 8개
100만 ~ 4444500 = 4개
100만 ~ 4444450 = 2개
100만 ~ 4444445 = 1개
그렇다 구간에 따라서 개수를 정제할 수 있다
예시로 10~70을 보자
우선 10~100 구간 호출 4개
50보다 큰지 확인 = 큼! 2개 가짐
80보다 큰가? no
77 보다 큰가? no
답 = 2개
아니야... 이렇게 구간을 나눌수가 없다 만약 그 사이의 수가 나오면 어떻게해...
구간 탐색중 검토해야할 구간이 생기면 해당 값보다 1자리 낮은 구간의 개수까지 더하고
낮은 구간부터 주어지는 B까지 브루트포스로 금민수를 찾는다????
가능할지도....
'''
def perm(a, z):
    global cnt
    if a == z:
        tmp = int("".join(pq))
        if start <= tmp <= end:
            cnt += 1
            return
        else:
            return

    else:
        category = [4, 7]
        for c in category:
            pq[a] = str(c)
            perm(a+1, z)
            pq[a] = 0


start, end = map(int, input().split())

cnt = 0

len_s = len(str(start))
len_e = len(str(end))

for i in range(len_s, len_e+1):
    if i == len_s:
        pq = [0] * i
        perm(0, len_s)

    elif i == len_e:
        pq = [0] * i
        perm(0, len_e)

    else:
        cnt += 2 ** i

print(cnt)
